<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>transwarp: transwarp Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">transwarp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">transwarp Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The transwarp namespace.  
<a href="namespacetranswarp.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetranswarp_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetranswarp_1_1detail.html">detail</a></td></tr>
<tr class="memdesc:namespacetranswarp_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detail namespace for internal functionality only. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtranswarp_1_1accept__any__type.html">accept_any_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The accept_any type. Used for tag dispatch.  <a href="structtranswarp_1_1accept__any__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtranswarp_1_1accept__type.html">accept_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The accept type. Used for tag dispatch.  <a href="structtranswarp_1_1accept__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtranswarp_1_1consume__any__type.html">consume_any_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The consume_any type. Used for tag dispatch.  <a href="structtranswarp_1_1consume__any__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtranswarp_1_1consume__type.html">consume_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The consume type. Used for tag dispatch.  <a href="structtranswarp_1_1consume__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtranswarp_1_1control__error.html">control_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when a task is used in unintended ways.  <a href="classtranswarp_1_1control__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtranswarp_1_1decay.html">decay</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes reference and const from a type.  <a href="structtranswarp_1_1decay.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtranswarp_1_1edge.html">edge</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An edge between two tasks.  <a href="classtranswarp_1_1edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtranswarp_1_1executor.html">executor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The executor interface used to perform custom task execution.  <a href="classtranswarp_1_1executor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtranswarp_1_1functor.html">functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for a user-defined functor that needs access to the associated task or a cancel point to stop a task while it's running.  <a href="classtranswarp_1_1functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtranswarp_1_1invalid__parameter.html">invalid_parameter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when an invalid parameter was passed to a function.  <a href="classtranswarp_1_1invalid__parameter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtranswarp_1_1itask.html">itask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An interface for the task class.  <a href="classtranswarp_1_1itask.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtranswarp_1_1listener.html">listener</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The listener interface to listen to events raised by tasks.  <a href="classtranswarp_1_1listener.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtranswarp_1_1no__op__functor.html">no_op_functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor not doing nothing.  <a href="structtranswarp_1_1no__op__functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtranswarp_1_1parallel.html">parallel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executor for parallel execution. Uses a simple thread pool.  <a href="classtranswarp_1_1parallel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtranswarp_1_1releaser.html">releaser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The releaser will release a task's future when the task's <code>after_satisfied</code> event was received which happens when all children received the task's result. The releaser should be used in cases where the task's result is only needed for consumption by its children and can then be discarded.  <a href="classtranswarp_1_1releaser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtranswarp_1_1result.html">result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result type of a std::shared_future&lt;T&gt;  <a href="structtranswarp_1_1result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtranswarp_1_1root__type.html">root_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The root type. Used for tag dispatch.  <a href="structtranswarp_1_1root__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtranswarp_1_1sequential.html">sequential</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executor for sequential execution. Runs functors sequentially on the same thread.  <a href="classtranswarp_1_1sequential.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtranswarp_1_1task.html">task</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The task class.  <a href="classtranswarp_1_1task.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtranswarp_1_1task_3_01ResultType_01_6_01_4.html">task&lt; ResultType &amp; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The task class (reference result type)  <a href="classtranswarp_1_1task_3_01ResultType_01_6_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtranswarp_1_1task_3_01void_01_4.html">task&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The task class (void result type)  <a href="classtranswarp_1_1task_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtranswarp_1_1task__canceled.html">task_canceled</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when a task is canceled.  <a href="classtranswarp_1_1task__canceled.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtranswarp_1_1task__destroyed.html">task_destroyed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown when a task was destroyed prematurely.  <a href="classtranswarp_1_1task__destroyed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtranswarp_1_1task__impl.html">task_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A task representing a piece of work given by functor and parent tasks. By connecting tasks a directed acyclic graph is built. Tasks should be created using the make_task factory functions.  <a href="classtranswarp_1_1task__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtranswarp_1_1task__pool.html">task_pool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A task pool that allows running multiple instances of the same task in parallel.  <a href="classtranswarp_1_1task__pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtranswarp_1_1timer.html">timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A timer that tracks the average idle, wait, and run time of each task it listens to.  <a href="classtranswarp_1_1timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtranswarp_1_1transwarp__error.html">transwarp_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for exceptions.  <a href="classtranswarp_1_1transwarp__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtranswarp_1_1value__task.html">value_task</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A value task that stores a single value and doesn't require scheduling. Value tasks should be created using the make_value_task factory functions.  <a href="classtranswarp_1_1value__task.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtranswarp_1_1wait__any__type.html">wait_any_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wait_any type. Used for tag dispatch.  <a href="structtranswarp_1_1wait__any__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtranswarp_1_1wait__type.html">wait_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wait type. Used for tag dispatch.  <a href="structtranswarp_1_1wait__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a74d93d44af5246251fd274b659873fd0"><td class="memItemLeft" align="right" valign="top"><a id="a74d93d44af5246251fd274b659873fd0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>any_data</b> = std::any</td></tr>
<tr class="separator:a74d93d44af5246251fd274b659873fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c2e9ea0591cc309256437cdcf0b545"><td class="memItemLeft" align="right" valign="top"><a id="a84c2e9ea0591cc309256437cdcf0b545"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>option_str</b> = std::optional&lt; std::string &gt;</td></tr>
<tr class="separator:a84c2e9ea0591cc309256437cdcf0b545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52938d631626dfe8515ee2de604d2aaa"><td class="memItemLeft" align="right" valign="top"><a id="a52938d631626dfe8515ee2de604d2aaa"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>str_view</b> = std::string_view</td></tr>
<tr class="separator:a52938d631626dfe8515ee2de604d2aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a10f2b2567332cf9514d4c366c1cc5a5e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetranswarp.html#a10f2b2567332cf9514d4c366c1cc5a5e">task_type</a> { <br />
&#160;&#160;<a class="el" href="namespacetranswarp.html#a10f2b2567332cf9514d4c366c1cc5a5ea63a9f0ea7bb98050796b649e85481845">task_type::root</a>, 
<a class="el" href="namespacetranswarp.html#a10f2b2567332cf9514d4c366c1cc5a5ea4abe77c201ff11663ccdf52fd6ecea86">task_type::accept</a>, 
<a class="el" href="namespacetranswarp.html#a10f2b2567332cf9514d4c366c1cc5a5ea8d2735d2d22decb39d4ddb7f6881adc4">task_type::accept_any</a>, 
<a class="el" href="namespacetranswarp.html#a10f2b2567332cf9514d4c366c1cc5a5eaf0ef8c72418989a4bb20243ccb61eeb0">task_type::consume</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetranswarp.html#a10f2b2567332cf9514d4c366c1cc5a5ea8bbb28bf2d86bf6249fb17e919cf672c">task_type::consume_any</a>, 
<a class="el" href="namespacetranswarp.html#a10f2b2567332cf9514d4c366c1cc5a5ea49256b9819abacbb8e6e031a03abe81b">task_type::wait</a>, 
<a class="el" href="namespacetranswarp.html#a10f2b2567332cf9514d4c366c1cc5a5ea3b703f81240f8b9b52ac233d26c13c99">task_type::wait_any</a>
<br />
 }</td></tr>
<tr class="memdesc:a10f2b2567332cf9514d4c366c1cc5a5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The possible task types.  <a href="namespacetranswarp.html#a10f2b2567332cf9514d4c366c1cc5a5e">More...</a><br /></td></tr>
<tr class="separator:a10f2b2567332cf9514d4c366c1cc5a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857009a6efbb2f34495ee81664a376dc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetranswarp.html#a857009a6efbb2f34495ee81664a376dc">event_type</a> { <br />
&#160;&#160;<a class="el" href="namespacetranswarp.html#a857009a6efbb2f34495ee81664a376dca35417532b100ce11672f583cf5d378bd">event_type::before_scheduled</a>, 
<a class="el" href="namespacetranswarp.html#a857009a6efbb2f34495ee81664a376dcaec60b71ee73a65a76b212c32a745480d">event_type::after_future_changed</a>, 
<a class="el" href="namespacetranswarp.html#a857009a6efbb2f34495ee81664a376dcad6e19f65753e84a061a28f9f305fe39b">event_type::before_started</a>, 
<a class="el" href="namespacetranswarp.html#a857009a6efbb2f34495ee81664a376dcaeecb3099ae4ef4be6fc0008dacf35a2d">event_type::before_invoked</a>, 
<br />
&#160;&#160;<a class="el" href="namespacetranswarp.html#a857009a6efbb2f34495ee81664a376dcac24f2a90b2418a40ec4eaf0c7e49a537">event_type::after_finished</a>, 
<a class="el" href="namespacetranswarp.html#a857009a6efbb2f34495ee81664a376dcaf6627ef1a493e0fdc9965eefcf89a425">event_type::after_canceled</a>, 
<a class="el" href="namespacetranswarp.html#a857009a6efbb2f34495ee81664a376dca01b7c5d10d321a4e101d5a389a67ade3">event_type::after_satisfied</a>, 
<a class="el" href="namespacetranswarp.html#a857009a6efbb2f34495ee81664a376dca46aa91fc92fdfedf990b1477e41f7606">event_type::after_custom_data_set</a>, 
<br />
&#160;&#160;<b>count</b>
<br />
 }</td></tr>
<tr class="memdesc:a857009a6efbb2f34495ee81664a376dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The task events that can be subscribed to using the listener interface.  <a href="namespacetranswarp.html#a857009a6efbb2f34495ee81664a376dc">More...</a><br /></td></tr>
<tr class="separator:a857009a6efbb2f34495ee81664a376dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab7cae8c7d0267dd51406f77f69697c3b"><td class="memItemLeft" align="right" valign="top"><a id="ab7cae8c7d0267dd51406f77f69697c3b"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetranswarp.html#ab7cae8c7d0267dd51406f77f69697c3b">to_string</a> (const <a class="el" href="namespacetranswarp.html#a10f2b2567332cf9514d4c366c1cc5a5e">transwarp::task_type</a> &amp;type)</td></tr>
<tr class="memdesc:ab7cae8c7d0267dd51406f77f69697c3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">String conversion for the task_type enumeration. <br /></td></tr>
<tr class="separator:ab7cae8c7d0267dd51406f77f69697c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c2d8b78809b7fb49cb723b712ff7ab"><td class="memItemLeft" align="right" valign="top"><a id="a17c2d8b78809b7fb49cb723b712ff7ab"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetranswarp.html#a17c2d8b78809b7fb49cb723b712ff7ab">to_string</a> (const <a class="el" href="classtranswarp_1_1itask.html">transwarp::itask</a> &amp;<a class="el" href="classtranswarp_1_1task.html">task</a>, transwarp::str_view separator=&quot;\n&quot;)</td></tr>
<tr class="memdesc:a17c2d8b78809b7fb49cb723b712ff7ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">String conversion for the itask class. <br /></td></tr>
<tr class="separator:a17c2d8b78809b7fb49cb723b712ff7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84bd844bca9f378d0f55b6cb52494ef"><td class="memItemLeft" align="right" valign="top"><a id="ad84bd844bca9f378d0f55b6cb52494ef"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetranswarp.html#ad84bd844bca9f378d0f55b6cb52494ef">to_string</a> (const <a class="el" href="classtranswarp_1_1edge.html">transwarp::edge</a> &amp;<a class="el" href="classtranswarp_1_1edge.html">edge</a>, transwarp::str_view separator=&quot;\n&quot;)</td></tr>
<tr class="memdesc:ad84bd844bca9f378d0f55b6cb52494ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">String conversion for the edge class. <br /></td></tr>
<tr class="separator:ad84bd844bca9f378d0f55b6cb52494ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98170d208211077a2aff51852c54c521"><td class="memItemLeft" align="right" valign="top"><a id="a98170d208211077a2aff51852c54c521"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetranswarp.html#a98170d208211077a2aff51852c54c521">to_string</a> (const std::vector&lt; <a class="el" href="classtranswarp_1_1edge.html">transwarp::edge</a> &gt; &amp;edges, transwarp::str_view separator=&quot;\n&quot;)</td></tr>
<tr class="memdesc:a98170d208211077a2aff51852c54c521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a dot-style string from the given edges. <br /></td></tr>
<tr class="separator:a98170d208211077a2aff51852c54c521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3cee9012db913de80ca9933a534f7a3"><td class="memTemplParams" colspan="2"><a id="ae3cee9012db913de80ca9933a534f7a3"></a>
template&lt;typename TaskType , typename Functor , typename... Parents&gt; </td></tr>
<tr class="memitem:ae3cee9012db913de80ca9933a534f7a3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetranswarp.html#ae3cee9012db913de80ca9933a534f7a3">make_task</a> (TaskType, Functor &amp;&amp;<a class="el" href="classtranswarp_1_1functor.html">functor</a>, std::shared_ptr&lt; Parents &gt;... parents) -&gt; std::shared_ptr&lt; <a class="el" href="classtranswarp_1_1task__impl.html">transwarp::task_impl</a>&lt; TaskType, typename std::decay&lt; Functor &gt;::type, typename Parents::result_type... &gt;&gt;</td></tr>
<tr class="memdesc:ae3cee9012db913de80ca9933a534f7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A factory function to create a new task. <br /></td></tr>
<tr class="separator:ae3cee9012db913de80ca9933a534f7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16aca2b1ca1f3f3afc76f935589264a"><td class="memTemplParams" colspan="2"><a id="ab16aca2b1ca1f3f3afc76f935589264a"></a>
template&lt;typename TaskType , typename Functor , typename ParentType &gt; </td></tr>
<tr class="memitem:ab16aca2b1ca1f3f3afc76f935589264a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetranswarp.html#ab16aca2b1ca1f3f3afc76f935589264a">make_task</a> (TaskType, Functor &amp;&amp;<a class="el" href="classtranswarp_1_1functor.html">functor</a>, std::vector&lt; ParentType &gt; parents) -&gt; std::shared_ptr&lt; <a class="el" href="classtranswarp_1_1task__impl.html">transwarp::task_impl</a>&lt; TaskType, typename std::decay&lt; Functor &gt;::type, std::vector&lt; ParentType &gt;&gt;&gt;</td></tr>
<tr class="memdesc:ab16aca2b1ca1f3f3afc76f935589264a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A factory function to create a new task with vector parents. <br /></td></tr>
<tr class="separator:ab16aca2b1ca1f3f3afc76f935589264a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8aab80faff265698b144510ee3f12b"><td class="memTemplParams" colspan="2"><a id="a3e8aab80faff265698b144510ee3f12b"></a>
template&lt;typename Value &gt; </td></tr>
<tr class="memitem:a3e8aab80faff265698b144510ee3f12b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetranswarp.html#a3e8aab80faff265698b144510ee3f12b">make_value_task</a> (Value &amp;&amp;value) -&gt; std::shared_ptr&lt; <a class="el" href="classtranswarp_1_1value__task.html">transwarp::value_task</a>&lt; typename <a class="el" href="structtranswarp_1_1decay.html">transwarp::decay</a>&lt; Value &gt;::type &gt;&gt;</td></tr>
<tr class="memdesc:a3e8aab80faff265698b144510ee3f12b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A factory function to create a new value task. <br /></td></tr>
<tr class="separator:a3e8aab80faff265698b144510ee3f12b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c17629c02b747537b8595da295b2daf"><td class="memTemplParams" colspan="2"><a id="a0c17629c02b747537b8595da295b2daf"></a>
template&lt;typename InputIt , typename UnaryOperation &gt; </td></tr>
<tr class="memitem:a0c17629c02b747537b8595da295b2daf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetranswarp.html#a0c17629c02b747537b8595da295b2daf">for_each</a> (InputIt first, InputIt last, UnaryOperation unary_op) -&gt; std::shared_ptr&lt; <a class="el" href="classtranswarp_1_1task__impl.html">transwarp::task_impl</a>&lt; <a class="el" href="structtranswarp_1_1wait__type.html">transwarp::wait_type</a>, <a class="el" href="structtranswarp_1_1no__op__functor.html">transwarp::no_op_functor</a>, std::vector&lt; std::shared_ptr&lt; <a class="el" href="classtranswarp_1_1task.html">transwarp::task</a>&lt; void &gt;&gt;&gt;&gt;&gt;</td></tr>
<tr class="memdesc:a0c17629c02b747537b8595da295b2daf"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function similar to std::for_each but returning a transwarp task for deferred, possibly asynchronous execution. This function creates a graph with std::distance(first, last) root tasks. <br /></td></tr>
<tr class="separator:a0c17629c02b747537b8595da295b2daf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce7d500801973d1ab012b3d11ec849c"><td class="memTemplParams" colspan="2"><a id="a8ce7d500801973d1ab012b3d11ec849c"></a>
template&lt;typename InputIt , typename UnaryOperation &gt; </td></tr>
<tr class="memitem:a8ce7d500801973d1ab012b3d11ec849c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetranswarp.html#a8ce7d500801973d1ab012b3d11ec849c">for_each</a> (<a class="el" href="classtranswarp_1_1executor.html">transwarp::executor</a> &amp;<a class="el" href="classtranswarp_1_1executor.html">executor</a>, InputIt first, InputIt last, UnaryOperation unary_op) -&gt; std::shared_ptr&lt; <a class="el" href="classtranswarp_1_1task__impl.html">transwarp::task_impl</a>&lt; <a class="el" href="structtranswarp_1_1wait__type.html">transwarp::wait_type</a>, <a class="el" href="structtranswarp_1_1no__op__functor.html">transwarp::no_op_functor</a>, std::vector&lt; std::shared_ptr&lt; <a class="el" href="classtranswarp_1_1task.html">transwarp::task</a>&lt; void &gt;&gt;&gt;&gt;&gt;</td></tr>
<tr class="memdesc:a8ce7d500801973d1ab012b3d11ec849c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function similar to std::for_each but returning a transwarp task for deferred, possibly asynchronous execution. This function creates a graph with std::distance(first, last) root tasks. Overload for automatic scheduling by passing an executor. <br /></td></tr>
<tr class="separator:a8ce7d500801973d1ab012b3d11ec849c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a19cc0b060cd02be9f1ae1115c202b2"><td class="memTemplParams" colspan="2"><a id="a8a19cc0b060cd02be9f1ae1115c202b2"></a>
template&lt;typename InputIt , typename OutputIt , typename UnaryOperation &gt; </td></tr>
<tr class="memitem:a8a19cc0b060cd02be9f1ae1115c202b2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetranswarp.html#a8a19cc0b060cd02be9f1ae1115c202b2">transform</a> (InputIt first1, InputIt last1, OutputIt d_first, UnaryOperation unary_op) -&gt; std::shared_ptr&lt; <a class="el" href="classtranswarp_1_1task__impl.html">transwarp::task_impl</a>&lt; <a class="el" href="structtranswarp_1_1wait__type.html">transwarp::wait_type</a>, <a class="el" href="structtranswarp_1_1no__op__functor.html">transwarp::no_op_functor</a>, std::vector&lt; std::shared_ptr&lt; <a class="el" href="classtranswarp_1_1task.html">transwarp::task</a>&lt; void &gt;&gt;&gt;&gt;&gt;</td></tr>
<tr class="memdesc:a8a19cc0b060cd02be9f1ae1115c202b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function similar to std::transform but returning a transwarp task for deferred, possibly asynchronous execution. This function creates a graph with std::distance(first1, last1) root tasks. <br /></td></tr>
<tr class="separator:a8a19cc0b060cd02be9f1ae1115c202b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0fb2854ab1008dce12dfb0ee36a4252"><td class="memTemplParams" colspan="2"><a id="ab0fb2854ab1008dce12dfb0ee36a4252"></a>
template&lt;typename InputIt , typename OutputIt , typename UnaryOperation &gt; </td></tr>
<tr class="memitem:ab0fb2854ab1008dce12dfb0ee36a4252"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetranswarp.html#ab0fb2854ab1008dce12dfb0ee36a4252">transform</a> (<a class="el" href="classtranswarp_1_1executor.html">transwarp::executor</a> &amp;<a class="el" href="classtranswarp_1_1executor.html">executor</a>, InputIt first1, InputIt last1, OutputIt d_first, UnaryOperation unary_op) -&gt; std::shared_ptr&lt; <a class="el" href="classtranswarp_1_1task__impl.html">transwarp::task_impl</a>&lt; <a class="el" href="structtranswarp_1_1wait__type.html">transwarp::wait_type</a>, <a class="el" href="structtranswarp_1_1no__op__functor.html">transwarp::no_op_functor</a>, std::vector&lt; std::shared_ptr&lt; <a class="el" href="classtranswarp_1_1task.html">transwarp::task</a>&lt; void &gt;&gt;&gt;&gt;&gt;</td></tr>
<tr class="memdesc:ab0fb2854ab1008dce12dfb0ee36a4252"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function similar to std::transform but returning a transwarp task for deferred, possibly asynchronous execution. This function creates a graph with std::distance(first1, last1) root tasks. Overload for automatic scheduling by passing an executor. <br /></td></tr>
<tr class="separator:ab0fb2854ab1008dce12dfb0ee36a4252"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a4636e35a2f178eda191ecf3d67325df4"><td class="memItemLeft" align="right" valign="top"><a id="a4636e35a2f178eda191ecf3d67325df4"></a>
constexpr <a class="el" href="structtranswarp_1_1root__type.html">transwarp::root_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetranswarp.html#a4636e35a2f178eda191ecf3d67325df4">root</a> {}</td></tr>
<tr class="memdesc:a4636e35a2f178eda191ecf3d67325df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The root task tag. <br /></td></tr>
<tr class="separator:a4636e35a2f178eda191ecf3d67325df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7267306a4cd9523f6ed5ea72c8e88a1"><td class="memItemLeft" align="right" valign="top"><a id="af7267306a4cd9523f6ed5ea72c8e88a1"></a>
constexpr <a class="el" href="structtranswarp_1_1accept__type.html">transwarp::accept_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetranswarp.html#af7267306a4cd9523f6ed5ea72c8e88a1">accept</a> {}</td></tr>
<tr class="memdesc:af7267306a4cd9523f6ed5ea72c8e88a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The accept task tag. <br /></td></tr>
<tr class="separator:af7267306a4cd9523f6ed5ea72c8e88a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb75f89ecc3e7ee36b86b5630e09ac67"><td class="memItemLeft" align="right" valign="top"><a id="acb75f89ecc3e7ee36b86b5630e09ac67"></a>
constexpr <a class="el" href="structtranswarp_1_1accept__any__type.html">transwarp::accept_any_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetranswarp.html#acb75f89ecc3e7ee36b86b5630e09ac67">accept_any</a> {}</td></tr>
<tr class="memdesc:acb75f89ecc3e7ee36b86b5630e09ac67"><td class="mdescLeft">&#160;</td><td class="mdescRight">The accept_any task tag. <br /></td></tr>
<tr class="separator:acb75f89ecc3e7ee36b86b5630e09ac67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c68e46c541428def37f2a23fa7b5ec2"><td class="memItemLeft" align="right" valign="top"><a id="a2c68e46c541428def37f2a23fa7b5ec2"></a>
constexpr <a class="el" href="structtranswarp_1_1consume__type.html">transwarp::consume_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetranswarp.html#a2c68e46c541428def37f2a23fa7b5ec2">consume</a> {}</td></tr>
<tr class="memdesc:a2c68e46c541428def37f2a23fa7b5ec2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The consume task tag. <br /></td></tr>
<tr class="separator:a2c68e46c541428def37f2a23fa7b5ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff5ff00b1049e223771e8692a216464"><td class="memItemLeft" align="right" valign="top"><a id="a6ff5ff00b1049e223771e8692a216464"></a>
constexpr <a class="el" href="structtranswarp_1_1consume__any__type.html">transwarp::consume_any_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetranswarp.html#a6ff5ff00b1049e223771e8692a216464">consume_any</a> {}</td></tr>
<tr class="memdesc:a6ff5ff00b1049e223771e8692a216464"><td class="mdescLeft">&#160;</td><td class="mdescRight">The consume_any task tag. <br /></td></tr>
<tr class="separator:a6ff5ff00b1049e223771e8692a216464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa169141eada06b21a91bb9e77f584f7c"><td class="memItemLeft" align="right" valign="top"><a id="aa169141eada06b21a91bb9e77f584f7c"></a>
constexpr <a class="el" href="structtranswarp_1_1wait__type.html">transwarp::wait_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetranswarp.html#aa169141eada06b21a91bb9e77f584f7c">wait</a> {}</td></tr>
<tr class="memdesc:aa169141eada06b21a91bb9e77f584f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wait task tag. <br /></td></tr>
<tr class="separator:aa169141eada06b21a91bb9e77f584f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd99c1e356b25c056d05b65586c4a25d"><td class="memItemLeft" align="right" valign="top"><a id="afd99c1e356b25c056d05b65586c4a25d"></a>
constexpr <a class="el" href="structtranswarp_1_1wait__any__type.html">transwarp::wait_any_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetranswarp.html#afd99c1e356b25c056d05b65586c4a25d">wait_any</a> {}</td></tr>
<tr class="memdesc:afd99c1e356b25c056d05b65586c4a25d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The wait_any task tag. <br /></td></tr>
<tr class="separator:afd99c1e356b25c056d05b65586c4a25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ab56f758bd0cedf93c6df51d4f4060"><td class="memItemLeft" align="right" valign="top"><a id="a58ab56f758bd0cedf93c6df51d4f4060"></a>
constexpr <a class="el" href="structtranswarp_1_1no__op__functor.html">no_op_functor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetranswarp.html#a58ab56f758bd0cedf93c6df51d4f4060">no_op</a> {}</td></tr>
<tr class="memdesc:a58ab56f758bd0cedf93c6df51d4f4060"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object to use in places where a no-op functor is required. <br /></td></tr>
<tr class="separator:a58ab56f758bd0cedf93c6df51d4f4060"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The transwarp namespace. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a857009a6efbb2f34495ee81664a376dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a857009a6efbb2f34495ee81664a376dc">&#9670;&nbsp;</a></span>event_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetranswarp.html#a857009a6efbb2f34495ee81664a376dc">transwarp::event_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The task events that can be subscribed to using the listener interface. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a857009a6efbb2f34495ee81664a376dca35417532b100ce11672f583cf5d378bd"></a>before_scheduled&#160;</td><td class="fielddoc"><p>Just before a task is scheduled (handle_event called on thread of caller to schedule()) </p>
</td></tr>
<tr><td class="fieldname"><a id="a857009a6efbb2f34495ee81664a376dcaec60b71ee73a65a76b212c32a745480d"></a>after_future_changed&#160;</td><td class="fielddoc"><p>Just after the task's future was changed (handle_event called on thread that changed the task's future) </p>
</td></tr>
<tr><td class="fieldname"><a id="a857009a6efbb2f34495ee81664a376dcad6e19f65753e84a061a28f9f305fe39b"></a>before_started&#160;</td><td class="fielddoc"><p>Just before a task starts running (handle_event called on thread that task is run on) </p>
</td></tr>
<tr><td class="fieldname"><a id="a857009a6efbb2f34495ee81664a376dcaeecb3099ae4ef4be6fc0008dacf35a2d"></a>before_invoked&#160;</td><td class="fielddoc"><p>Just before a task's functor is invoked (handle_event called on thread that task is run on) </p>
</td></tr>
<tr><td class="fieldname"><a id="a857009a6efbb2f34495ee81664a376dcac24f2a90b2418a40ec4eaf0c7e49a537"></a>after_finished&#160;</td><td class="fielddoc"><p>Just after a task has finished running (handle_event called on thread that task is run on) </p>
</td></tr>
<tr><td class="fieldname"><a id="a857009a6efbb2f34495ee81664a376dcaf6627ef1a493e0fdc9965eefcf89a425"></a>after_canceled&#160;</td><td class="fielddoc"><p>Just after a task was canceled (handle_event called on thread that task is run on) </p>
</td></tr>
<tr><td class="fieldname"><a id="a857009a6efbb2f34495ee81664a376dca01b7c5d10d321a4e101d5a389a67ade3"></a>after_satisfied&#160;</td><td class="fielddoc"><p>Just after a task has satisfied all its children with results (handle_event called on thread where the last child is satisfied) </p>
</td></tr>
<tr><td class="fieldname"><a id="a857009a6efbb2f34495ee81664a376dca46aa91fc92fdfedf990b1477e41f7606"></a>after_custom_data_set&#160;</td><td class="fielddoc"><p>Just after custom data was assigned (handle_event called on thread that custom data was set on) </p>
</td></tr>
</table>

</div>
</div>
<a id="a10f2b2567332cf9514d4c366c1cc5a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10f2b2567332cf9514d4c366c1cc5a5e">&#9670;&nbsp;</a></span>task_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetranswarp.html#a10f2b2567332cf9514d4c366c1cc5a5e">transwarp::task_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The possible task types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a10f2b2567332cf9514d4c366c1cc5a5ea63a9f0ea7bb98050796b649e85481845"></a>root&#160;</td><td class="fielddoc"><p>The task has no parents. </p>
</td></tr>
<tr><td class="fieldname"><a id="a10f2b2567332cf9514d4c366c1cc5a5ea4abe77c201ff11663ccdf52fd6ecea86"></a>accept&#160;</td><td class="fielddoc"><p>The task's functor accepts all parent futures. </p>
</td></tr>
<tr><td class="fieldname"><a id="a10f2b2567332cf9514d4c366c1cc5a5ea8d2735d2d22decb39d4ddb7f6881adc4"></a>accept_any&#160;</td><td class="fielddoc"><p>The task's functor accepts the first parent future that becomes ready. </p>
</td></tr>
<tr><td class="fieldname"><a id="a10f2b2567332cf9514d4c366c1cc5a5eaf0ef8c72418989a4bb20243ccb61eeb0"></a>consume&#160;</td><td class="fielddoc"><p>The task's functor consumes all parent results. </p>
</td></tr>
<tr><td class="fieldname"><a id="a10f2b2567332cf9514d4c366c1cc5a5ea8bbb28bf2d86bf6249fb17e919cf672c"></a>consume_any&#160;</td><td class="fielddoc"><p>The task's functor consumes the first parent result that becomes ready. </p>
</td></tr>
<tr><td class="fieldname"><a id="a10f2b2567332cf9514d4c366c1cc5a5ea49256b9819abacbb8e6e031a03abe81b"></a>wait&#160;</td><td class="fielddoc"><p>The task's functor takes no arguments but waits for all parents to finish. </p>
</td></tr>
<tr><td class="fieldname"><a id="a10f2b2567332cf9514d4c366c1cc5a5ea3b703f81240f8b9b52ac233d26c13c99"></a>wait_any&#160;</td><td class="fielddoc"><p>The task's functor takes no arguments but waits for the first parent to finish. </p>
</td></tr>
</table>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
